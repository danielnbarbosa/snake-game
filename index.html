<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no">
  <title>Snakes v4</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="apple-touch-icon" href="icons/icon-180.png">
  <link rel="manifest" href="manifest.webmanifest">
  <style>
    html, body { margin:0; height:100%; background:#0b0e0f; color:#fff; font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif; }
    #wrap { display:flex; flex-direction:column; align-items:center; justify-content:center; height:100%; gap:10px; }
    canvas { background:#050607; touch-action:none; border-radius:12px; box-shadow: 0 6px 22px rgba(0,0,0,.55); }
    #hud { display:flex; gap:12px; align-items:center; font-weight:600; flex-wrap:wrap; justify-content:center; }
    #buttons { display:grid; grid-template-columns: 64px 64px 64px; grid-template-rows: 64px 64px 64px; gap:8px; user-select:none; -webkit-user-select:none; }
    .btn { background:#161a1d; border:1px solid #2a2f33; border-radius:12px; display:flex; align-items:center; justify-content:center; font-size:22px; font-weight:700; }
    .btn:active { transform:scale(0.98); }
    .ghost { visibility:hidden; }
    #tip { opacity:.75; font-size: 13px; text-align:center; max-width: 700px;}
    a { color:#9fe870; text-decoration: none; }
    #pause, #restart, #mute { padding:10px 14px; }
    .chip { padding:.25rem .5rem; border:1px solid #2a2f33; border-radius:999px; font-size:12px; opacity:.9 }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game" width="480" height="480" aria-label="Snakes game area"></canvas>
    <div id="hud">
      <div class="chip">Score: <span id="score">0</span></div>
      <div class="chip">Best: <span id="best">0</span></div>
      <div class="chip">Snakes: <span id="nsnakes">0</span></div>
      <div class="chip">Apples: <span id="napples">0</span></div>
      <button id="pause" class="btn">‚è∏Ô∏é</button>
      <button id="restart" class="btn">‚Üª</button>
      <button id="mute" class="btn" aria-pressed="false">üîä</button>
    </div>
    <div id="buttons" aria-label="Directional controls" role="group">
      <div class="ghost"></div>
      <div class="btn" data-dir="up">‚ñ≤</div>
      <div class="ghost"></div>
      <div class="btn" data-dir="left">‚óÄ</div>
      <div class="btn" data-dir="down">‚ñº</div>
      <div class="btn" data-dir="right">‚ñ∂</div>
      <div class="ghost"></div><div class="ghost"></div><div class="ghost"></div>
    </div>
    <div id="tip">
      Wrap-around walls are back. Eat <b>apples</b> to grow.
      Combat rules: if your snake is <b>larger or equal</b>, you can eat other snakes <i>from anywhere</i> (head, side, tail). If you're <b>smaller</b>, you can't eat them‚Äîyou just bounce off.
    </div>
  </div>

<script>
// ---- PWA: service worker ----
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./sw.js').catch(()=>{});
  });
}

// ---- Audio ----
let audio = { ctx: null, enabled: true };
function initAudio() {
  if (audio.ctx) return;
  try { audio.ctx = new (window.AudioContext || window.webkitAudioContext)(); } catch(e) { audio.enabled = false; }
}
function beep(freq=440, dur=0.08, type='sine', gain=0.03) {
  if (!audio.enabled || !audio.ctx) return;
  const ctx = audio.ctx;
  const t0 = ctx.currentTime;
  const o = ctx.createOscillator();
  const g = ctx.createGain();
  o.type = type;
  o.frequency.setValueAtTime(freq, t0);
  g.gain.setValueAtTime(gain, t0);
  g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
  o.connect(g).connect(ctx.destination);
  o.start(t0);
  o.stop(t0 + dur);
}
function sfxApple(){ beep(320, .06, 'triangle', .05); }
function sfxEatSnake(){ beep(220, .07, 'triangle', .05); setTimeout(()=>beep(370, .07, 'triangle', .05), 60); }
function sfxDead(){ beep(120, .18, 'sawtooth', .04); setTimeout(()=>beep(90, .22, 'sawtooth', .035), 120); }
function sfxBounce(){ beep(180, .05, 'square', .04); }
window.addEventListener('touchstart', () => { if (!audio.ctx && audio.enabled) { initAudio(); } }, {passive:true});
window.addEventListener('mousedown', () => { if (!audio.ctx && audio.enabled) { initAudio(); } });

// ---- Game constants ----
const COLS = 24, ROWS = 24;
const CELL = 20;
const CANVAS_SIZE = 480;
const TICK_MS_PLAYER = 190;        // slower player
const AI_STEP_INTERVAL = 2;        // AI moves once every N player ticks (slower than player)
const NPC_MAX = 2;                 // at most two AI snakes
const PLAYER_START_LEN = 3;        // small start
const APPLE_COUNT = 5;             // apples on board
const MAX_LEN = COLS*ROWS - 1;

// Colors: player vs AI
const PLAYER_SKIN = { dark:'#0f3a23', mid:'#1f6b3c', lite:'#3fd47a' };
const AI_SKIN      = { dark:'#3a1f0f', mid:'#6b3c1f', lite:'#e69a58' };

// ---- State ----
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const bestEl = document.getElementById('best');
const nsnakesEl = document.getElementById('nsnakes');
const napplesEl = document.getElementById('napples');
const pauseBtn = document.getElementById('pause');
const restartBtn = document.getElementById('restart');
const muteBtn = document.getElementById('mute');

let player, npcs, apples, dir, nextDir, score, best, paused, dead;
let tickAccum = 0, lastTs = performance.now(), tickCount = 0;

best = parseInt(localStorage.getItem('best-score-v4') || '0', 10);
bestEl.textContent = best;

// Fit canvas CSS size
function fit() {
  const pad = 16;
  const size = Math.min(window.innerWidth, window.innerHeight) - pad*2;
  const s = Math.max(300, Math.min(700, size));
  canvas.style.width = s + 'px';
  canvas.style.height = s + 'px';
}
fit();
window.addEventListener('resize', fit);

// Helpers
function rnd(n){ return Math.floor(Math.random()*n); }
function wrap(v, max){ return (v + max) % max; }
function cellEq(a,b){ return a.x===b.x && a.y===b.y; }
function anyAt(pos, arr){ return arr.some(p=>cellEq(p,pos)); }

function newSnake(len, skin, avoid=[]) {
  for (let tries=0; tries<200; tries++) {
    const horizontal = Math.random() < 0.5;
    const x = rnd(COLS), y = rnd(ROWS);
    const dir = horizontal ? (Math.random()<0.5?'left':'right') : (Math.random()<0.5?'up':'down');
    const body = [];
    for (let i=0;i<len;i++){
      let cx=x, cy=y;
      if (dir==='left')  cx = wrap(x+i, COLS);
      if (dir==='right') cx = wrap(x-i, COLS);
      if (dir==='up')    cy = wrap(y+i, ROWS);
      if (dir==='down')  cy = wrap(y-i, ROWS);
      const pos = {x:cx, y:cy};
      if (avoid.some(s=>s.body.some(p=>cellEq(p,pos)))) { body.length=0; break; }
      body.push(pos);
    }
    if (body.length===len) {
      return { body, dir, nextDir: dir, skin, ai: false, lastTail: null };
    }
  }
  // fallback center
  return { body:[{x:Math.floor(COLS/2), y:Math.floor(ROWS/2)}], dir:'right', nextDir:'right', skin, ai:false, lastTail:null };
}

function reset() {
  score = 0; scoreEl.textContent = score;
  paused = false; dead = false;
  player = newSnake(PLAYER_START_LEN, PLAYER_SKIN);
  npcs = [];
  for (let i=0;i<NPC_MAX;i++) spawnNPC();
  nsnakesEl.textContent = npcs.length;
  dir='right'; nextDir='right';
  apples = [];
  for (let i=0;i<APPLE_COUNT;i++) spawnApple();
  napplesEl.textContent = apples.length;
  tickAccum = 0; lastTs = performance.now(); tickCount = 0;
}
reset();

// Controls
function setDir(d) {
  const opposite = { up:'down', down:'up', left:'right', right:'left' };
  if (d !== opposite[dir]) nextDir = d;
}
document.getElementById('buttons').addEventListener('touchstart', e => {
  const t = e.target.closest('.btn'); if (t && t.dataset.dir) { setDir(t.dataset.dir); e.preventDefault(); }
}, {passive:false});
document.getElementById('buttons').addEventListener('click', e => {
  const t = e.target.closest('.btn'); if (t && t.dataset.dir) setDir(t.dataset.dir);
});
let touchStart=null;
canvas.addEventListener('touchstart', e=>{ const t=e.changedTouches[0]; touchStart={x:t.clientX,y:t.clientY}; e.preventDefault(); }, {passive:false});
canvas.addEventListener('touchmove', e=>{ e.preventDefault(); }, {passive:false});
canvas.addEventListener('touchend', e=>{
  if (!touchStart) return;
  const t=e.changedTouches[0], dx=t.clientX-touchStart.x, dy=t.clientY-touchStart.y;
  if (Math.abs(dx)>Math.abs(dy)) setDir(dx>0?'right':'left'); else if (Math.abs(dy)>8) setDir(dy>0?'down':'up');
  touchStart=null; e.preventDefault();
}, {passive:false});
window.addEventListener('keydown', e => {
  const k=e.key;
  if (k==='ArrowUp') setDir('up');
  else if (k==='ArrowDown') setDir('down');
  else if (k==='ArrowLeft') setDir('left');
  else if (k==='ArrowRight') setDir('right');
  else if (k===' ' || k==='Enter') togglePause();
  else if (k.toLowerCase()==='m') toggleMute();
});

pauseBtn.addEventListener('click', togglePause);
restartBtn.addEventListener('click', ()=>reset());
muteBtn.addEventListener('click', toggleMute);

function togglePause() {
  if (dead) reset();
  else paused = !paused;
  pauseBtn.textContent = paused ? '‚ñ∂Ô∏é' : '‚è∏Ô∏é';
}
function toggleMute() {
  audio.enabled = !audio.enabled;
  if (audio.enabled && !audio.ctx) initAudio();
  muteBtn.textContent = audio.enabled ? 'üîä' : 'üîá';
  muteBtn.setAttribute('aria-pressed', (!audio.enabled).toString());
}

// ---- Game loop ----
requestAnimationFrame(loop);
function loop(ts) {
  const dt = ts - lastTs; lastTs = ts; tickAccum += dt;
  while (tickAccum >= TICK_MS_PLAYER) {
    if (!paused && !dead) step();
    tickAccum -= TICK_MS_PLAYER;
    tickCount++;
  }
  render();
  requestAnimationFrame(loop);
}

// ---- Logic ----
function moveHeadWrap(pos, d) {
  const head = {x:pos.x, y:pos.y};
  if (d==='left') head.x = wrap(head.x-1, COLS);
  else if (d==='right') head.x = wrap(head.x+1, COLS);
  else if (d==='up') head.y = wrap(head.y-1, ROWS);
  else if (d==='down') head.y = wrap(head.y+1, ROWS);
  return head;
}

function moveSnake(snake, d) {
  const next = moveHeadWrap(snake.body[0], d);
  const oldTail = snake.body[snake.body.length-1];
  snake.body.unshift(next);
  snake.lastTail = {...oldTail};
  snake.body.pop();
  return { newHead: next, oldTail };
}

function undoMove(snake) {
  // remove the last inserted head and restore the lastTail
  snake.body.shift();
  if (snake.lastTail) snake.body.push(snake.lastTail);
}

function growSnake(snake, n=1) {
  for (let i=0;i<n;i++) {
    const tail = snake.body[snake.body.length-1];
    snake.body.push({...tail});
  }
}

function step() {
  // Player move
  const prevDir = dir;
  dir = nextDir;
  moveSnake(player, dir);

  // Apples
  const aIndex = apples.findIndex(p => cellEq(p, player.body[0]));
  if (aIndex !== -1) {
    apples.splice(aIndex,1);
    napplesEl.textContent = apples.length;
    sfxApple();
    score += 1; scoreEl.textContent = score;
    if (score > best) { best = score; bestEl.textContent = best; localStorage.setItem('best-score-v4', best); }
    growSnake(player, 1);
    spawnApple();
    napplesEl.textContent = apples.length;
  }

  // AI snakes move slower: only on certain ticks
  if (tickCount % AI_STEP_INTERVAL === 0) {
    for (const s of npcs) {
      // simple wandering AI
      const opposite = { up:'down', down:'up', left:'right', right:'left' };
      if (Math.random() < 0.25) {
        const options = ['up','down','left','right'].filter(x=>x!==opposite[s.dir]);
        s.nextDir = options[rnd(options.length)];
      }
      s.dir = s.nextDir;
      moveSnake(s, s.dir);
    }
  }

  // Player with self
  for (let i=1;i<player.body.length;i++) if (cellEq(player.body[0], player.body[i])) return gameOver();

  // Player vs NPCs collisions with new rules
  for (let i=0;i<npcs.length;i++) {
    const npc = npcs[i];
    // Did player's head collide with any part of npc?
    const idx = npc.body.findIndex(p => cellEq(p, player.body[0]));
    if (idx !== -1) {
      const playerLen = player.body.length;
      const targetLen = npc.body.length;
      if (playerLen >= targetLen) {
        // Eat anywhere
        sfxEatSnake();
        score += targetLen; scoreEl.textContent = score;
        if (score > best) { best = score; bestEl.textContent = best; localStorage.setItem('best-score-v4', best); }
        growSnake(player, Math.min(targetLen, 40));
        replaceNPC(npc);
        return;
      } else {
        // Smaller -> bounce (no death): undo the move & reverse direction
        sfxBounce();
        undoMove(player);
        // reverse direction away from impact
        const opposite = { up:'down', down:'up', left:'right', right:'left' };
        dir = opposite[dir]; nextDir = dir;
        return;
      }
    }
  }
}

function replaceNPC(old) {
  const idx = npcs.indexOf(old);
  if (idx !== -1) npcs.splice(idx,1);
  spawnNPC();
  nsnakesEl.textContent = npcs.length;
}

function spawnNPC() {
  if (npcs.length >= NPC_MAX) return;
  const len = 3 + rnd(6); // 3..8
  const s = newSnake(len, AI_SKIN, [player, ...npcs]);
  s.ai = true;
  npcs.push(s);
}

function spawnApple() {
  // ensure not spawning inside snakes or over existing apples
  for (let i=0;i<500;i++) {
    const pos = {x:rnd(COLS), y:rnd(ROWS)};
    const occupied = anyAt(pos, player.body) || npcs.some(s=>anyAt(pos, s.body)) || anyAt(pos, apples||[]);
    if (!occupied) { apples.push(pos); return; }
  }
}

// ---- Rendering ----
function render() {
  // background
  ctx.fillStyle = '#061013';
  ctx.fillRect(0,0,CANVAS_SIZE,CANVAS_SIZE);

  // subtle grid
  ctx.save();
  ctx.globalAlpha = 0.10;
  ctx.strokeStyle = '#0f1b1f';
  ctx.lineWidth = 1;
  for (let x=1;x<COLS;x++) { ctx.beginPath(); ctx.moveTo(x*CELL,0); ctx.lineTo(x*CELL,CANVAS_SIZE); ctx.stroke(); }
  for (let y=1;y<ROWS;y++) { ctx.beginPath(); ctx.moveTo(0,y*CELL); ctx.lineTo(CANVAS_SIZE,y*CELL); ctx.stroke(); }
  ctx.restore();

  // apples
  for (const p of apples) drawApple(p.x, p.y);

  // draw NPCs
  for (const s of npcs) drawSnake(s);
  // draw player on top
  drawSnake(player, true);

  if (paused) overlay('Paused');
  if (dead) overlay('Game Over');
}

function drawApple(cx, cy) {
  const x = cx*CELL + CELL/2;
  const y = cy*CELL + CELL/2;
  const r = Math.max(4, Math.floor(CELL*0.22));
  // apple body
  ctx.fillStyle = '#e74c3c';
  ctx.beginPath(); ctx.arc(x-2, y, r*0.95, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(x+2, y, r*0.95, 0, Math.PI*2); ctx.fill();
  // highlight
  ctx.fillStyle = 'rgba(255,255,255,0.15)';
  ctx.beginPath(); ctx.arc(x-4, y-3, r*0.45, 0, Math.PI*2); ctx.fill();
  // stem
  ctx.strokeStyle = '#5d3a1a'; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(x, y-r*1.1); ctx.lineTo(x+3, y-r*1.55); ctx.stroke();
  // leaf
  ctx.fillStyle = '#2ecc71';
  ctx.beginPath();
  ctx.ellipse(x+6, y-r*1.25, 3, 6, Math.PI/6, 0, Math.PI*2);
  ctx.fill();
}

function drawSnake(s, isPlayer=false) {
  // body
  for (let i=s.body.length-1; i>=0; i--) {
    const p = s.body[i];
    const band = (i%4===0);
    const col = band ? s.skin.dark : s.skin.mid;
    drawScaleCell(p.x, p.y, col, isPlayer && i===0 ? 6 : 4);
  }
  // head + eyes
  const head = s.body[0];
  drawScaleCell(head.x, head.y, s.skin.lite, 8);
  const cx = head.x*CELL + CELL/2;
  const cy = head.y*CELL + CELL/2;
  ctx.fillStyle = '#000';
  const eye = Math.max(2, Math.floor(CELL*0.08));
  ctx.beginPath(); ctx.arc(cx - CELL*0.18, cy - CELL*0.18, eye, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(cx + CELL*0.18, cy - CELL*0.18, eye, 0, Math.PI*2); ctx.fill();
  // tongue (player only)
  if (isPlayer && Math.random()<0.07) {
    ctx.strokeStyle = '#d24';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(cx, cy);
    let tx=cx, ty=cy;
    const d = (typeof nextDir!=='undefined') ? nextDir : 'right';
    if (d==='left') tx -= CELL*0.35;
    if (d==='right') tx += CELL*0.35;
    if (d==='up') ty -= CELL*0.35;
    if (d==='down') ty += CELL*0.35;
    ctx.lineTo(tx, ty); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(tx, ty); ctx.lineTo(tx+2, ty+2); ctx.moveTo(tx, ty); ctx.lineTo(tx-2, ty-2); ctx.stroke();
  }
}

function drawScaleCell(cx, cy, color, round=6) {
  const pad = 2;
  const x = cx*CELL+pad, y = cy*CELL+pad, w = CELL-2*pad, h = CELL-2*pad;
  const grad = ctx.createLinearGradient(x, y, x+w, y+h);
  grad.addColorStop(0, color);
  grad.addColorStop(1, 'rgba(255,255,255,0.07)');
  ctx.fillStyle = grad;
  ctx.beginPath();
  roundRect(ctx, x, y, w, h, round);
  ctx.fill();
  ctx.globalAlpha = 0.12;
  ctx.fillStyle = '#000';
  const step = Math.max(4, Math.floor(w/5));
  for (let yy=y+2; yy<y+h-2; yy+=step) {
    for (let xx=x+2; xx<x+w-2; xx+=step) {
      ctx.fillRect(xx, yy, 1, 1);
    }
  }
  ctx.globalAlpha = 1;
}

function roundRect(ctx, x, y, w, h, r) {
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y, x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x, y+h, r);
  ctx.arcTo(x, y+h, x, y, r);
  ctx.arcTo(x, y, x+w, y, r);
}

function overlay(text) {
  ctx.fillStyle = 'rgba(0,0,0,.55)';
  ctx.fillRect(0,0,canvas.width, canvas.height);
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 28px system-ui, -apple-system, Segoe UI, Roboto';
  ctx.textAlign = 'center';
  ctx.fillText(text, canvas.width/2, canvas.height/2);
  ctx.font = '14px system-ui, -apple-system, Segoe UI, Roboto';
  ctx.fillText('Tap ‚ñ∂Ô∏é to resume or ‚Üª to restart', canvas.width/2, canvas.height/2 + 28);
}

function gameOver() { dead = true; sfxDead(); }
</script>
</body>
</html>
