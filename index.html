<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no">
  <title>Snakes v9</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="apple-touch-icon" href="icons/icon-180.png">
  <link rel="manifest" href="manifest.webmanifest">
  <style>
    :root { 
      --inset-top: env(safe-area-inset-top, 0px);
      --inset-right: env(safe-area-inset-right, 0px);
      --inset-bottom: env(safe-area-inset-bottom, 0px);
      --inset-left: env(safe-area-inset-left, 0px);
    }
    html, body { margin:0; padding:0; width:100%; height:100%; background:#000; }
    body { overscroll-behavior:none; display:flex; align-items:center; justify-content:center;
           padding: var(--inset-top) var(--inset-right) var(--inset-bottom) var(--inset-left); }
    #game { display:block; width:100vmin; height:100vmin; max-width:100%; max-height:100%; background:#050607; touch-action:none; border-radius:12px; }
  </style>
</head>
<body>
  <canvas id="game" width="480" height="480" aria-label="Snakes game area"></canvas>

<script>
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./sw.js').catch(()=>{});
  });
}

// ---- Audio ----
let audio = { ctx: null, enabled: true };
function initAudio() { if (audio.ctx) return; try { audio.ctx = new (window.AudioContext || window.webkitAudioContext)(); } catch(e) { audio.enabled = false; } }
function beep(freq=440, dur=0.08, type='sine', gain=0.03) {
  if (!audio.enabled || !audio.ctx) return;
  const ctx = audio.ctx, t0 = ctx.currentTime;
  const o = ctx.createOscillator(), g = ctx.createGain();
  o.type = type; o.frequency.setValueAtTime(freq, t0);
  g.gain.setValueAtTime(gain, t0); g.gain.exponentialRampToValueAtTime(0.0001, t0+dur);
  o.connect(g).connect(ctx.destination); o.start(t0); o.stop(t0+dur);
}
function sfxApple(){ beep(320, .06, 'triangle', .05); }
function sfxEatSnake(){ beep(220, .07, 'triangle', .05); setTimeout(()=>beep(370, .07, 'triangle', .05), 60); }
function sfxDead(){ beep(120, .18, 'sawtooth', .04); setTimeout(()=>beep(90, .22, 'sawtooth', .035), 120); }
function sfxBounce(){ beep(180, .05, 'square', .04); }
window.addEventListener('touchstart', () => { if (!audio.ctx && audio.enabled) initAudio(); }, {passive:true});
window.addEventListener('mousedown', () => { if (!audio.ctx && audio.enabled) initAudio(); });

// ---- World & board ----
const VIEW_SIZE = 480;          // viewport logical size (square)
const COLS = 24, ROWS = 24;     // viewport logical grid for rendering helpers (kept for grid density)
const CELL = VIEW_SIZE / COLS;

const WORLD_COLS = 96;          // much larger world
const WORLD_ROWS = 96;
const WORLD_W = WORLD_COLS * CELL;  // in logical px
const WORLD_H = WORLD_ROWS * CELL;

const TICK_MS_PLAYER = 190;
const AI_STEP_INTERVAL = 2;
const NPC_MAX = 2;
const PLAYER_START_LEN = 3;
const APPLE_COUNT = 40;         // more apples for big world

const PLAYER_STYLE = { base:'#41d281', edge:'#072416', highlight:'rgba(255,255,255,0.25)', neon:'#4dff9a', stripe:'#1a834f' };
const AI_STYLE      = { base:'#e8a45a', edge:'#3a1f0f', highlight:'rgba(255,255,255,0.20)', neon:'#ffc26b', stripe:'#8a4a16' };

// ---- State ----
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let score=0, best=parseInt(localStorage.getItem('best-score-v9')||'0',10), paused=false, dead=false;
let player, npcs, apples, dir, nextDir;
let tickAccum = 0, lastTs = performance.now(), tickCount = 0;
let camX = 0, camY = 0; // camera top-left in logical px

// Finger steering
let steerPoint=null;

function fitCanvas() {
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const rectW = window.innerWidth;
  const rectH = window.innerHeight;
  const sizeCss = Math.min(rectW, rectH); // square
  canvas.style.width = sizeCss + 'px';
  canvas.style.height = sizeCss + 'px';
  canvas.width = Math.floor(sizeCss * dpr);
  canvas.height = Math.floor(sizeCss * dpr);
  const scale = (canvas.width / VIEW_SIZE);
  ctx.setTransform(scale, 0, 0, scale, 0, 0);
}
fitCanvas();
window.addEventListener('resize', fitCanvas);

// Helpers
function rnd(n){ return Math.floor(Math.random()*n); }
function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
function inBounds(x,y){ return x>=0 && x<WORLD_COLS && y>=0 && y<WORLD_ROWS; }
function cellEq(a,b){ return a.x===b.x && a.y===b.y; }
function anyAt(pos, arr){ return arr.some(p=>cellEq(p,pos)); }

function newSnake(len, style, avoid=[]) {
  for (let tries=0; tries<400; tries++) {
    const horizontal = Math.random() < 0.5;
    const x = rnd(WORLD_COLS), y = rnd(WORLD_ROWS);
    const dir = horizontal ? (Math.random()<0.5?'left':'right') : (Math.random()<0.5?'up':'down');
    const body = [];
    for (let i=0;i<len;i++){
      let cx=x, cy=y;
      if (dir==='left')  cx = x+i;
      if (dir==='right') cx = x-i;
      if (dir==='up')    cy = y+i;
      if (dir==='down')  cy = y-i;
      const pos = {x:cx, y:cy};
      if (!inBounds(cx,cy) || avoid.some(s=>s.body.some(p=>cellEq(p,pos)))) { body.length=0; break; }
      body.push(pos);
    }
    if (body.length===len) return { body, dir, nextDir: dir, style, ai: false, lastTail: null };
  }
  return { body:[{x:Math.floor(WORLD_COLS/2), y:Math.floor(WORLD_ROWS/2)}], dir:'right', nextDir:'right', style, ai:false, lastTail:null };
}

function centerCamera() {
  const head = player.body[0];
  const headPxX = head.x * CELL + CELL/2;
  const headPxY = head.y * CELL + CELL/2;
  camX = clamp(headPxX - VIEW_SIZE/2, 0, WORLD_W - VIEW_SIZE);
  camY = clamp(headPxY - VIEW_SIZE/2, 0, WORLD_H - VIEW_SIZE);
}

function reset() {
  score = 0; paused=false; dead=false;
  player = newSnake(PLAYER_START_LEN, PLAYER_STYLE);
  npcs = []; for (let i=0;i<NPC_MAX;i++) spawnNPC();
  apples = []; for (let i=0;i<APPLE_COUNT;i++) spawnApple();
  dir='right'; nextDir='right';
  tickAccum = 0; lastTs = performance.now(); tickCount = 0;
  centerCamera();
}
reset();

// Steering (drag anywhere)
canvas.addEventListener('touchstart', e=>{
  const t=e.changedTouches[0];
  if (dead) { reset(); return; }
  if (paused) { paused=false; }
  steerPoint={x:t.clientX,y:t.clientY}; e.preventDefault();
},{passive:false});
canvas.addEventListener('touchmove', e=>{
  const t=e.changedTouches[0];
  steerPoint={x:t.clientX,y:t.clientY};
  steerToward(steerPoint);
  e.preventDefault();
},{passive:false});
canvas.addEventListener('touchend', e=>{ steerPoint=null; e.preventDefault(); }, {passive:false});
canvas.addEventListener('mousedown', e=>{
  if (dead) { reset(); return; }
  if (paused) { paused=false; return; }
  paused = !paused;
});

function steerToward(pt){
  const rect = canvas.getBoundingClientRect();
  // Convert finger to world logical px by adding camera offset
  const fx = (pt.x - rect.left) / rect.width * VIEW_SIZE + camX;
  const fy = (pt.y - rect.top) / rect.height * VIEW_SIZE + camY;
  const head = { x: player.body[0].x*CELL + CELL/2, y: player.body[0].y*CELL + CELL/2 };
  let dx = fx - head.x, dy = fy - head.y;
  const adx = Math.abs(dx), ady = Math.abs(dy);
  const desired = adx > ady ? (dx>0?'right':'left') : (dy>0?'down':'up');
  setDir(desired);
}

function setDir(d) {
  const opposite = { up:'down', down:'up', left:'right', right:'left' };
  if (d !== opposite[dir]) nextDir = d;
}

// Keyboard (optional)
window.addEventListener('keydown', e => {
  const k=e.key;
  if (k==='ArrowUp') setDir('up');
  else if (k==='ArrowDown') setDir('down');
  else if (k==='ArrowLeft') setDir('left');
  else if (k==='ArrowRight') setDir('right');
  else if (k===' ' || k==='Enter') { if (dead) reset(); else paused = !paused; }
  else if (k.toLowerCase()==='m') toggleMute();
});

function toggleMute(){ audio.enabled=!audio.enabled; if (audio.enabled && !audio.ctx) initAudio(); }

// ---- Game loop ----
requestAnimationFrame(loop);
function loop(ts) {
  const dt = ts - lastTs; lastTs = ts; tickAccum += dt;
  while (tickAccum >= TICK_MS_PLAYER) {
    if (!paused && !dead) step();
    tickAccum -= TICK_MS_PLAYER;
    tickCount++;
  }
  render();
  requestAnimationFrame(loop);
}

// ---- Logic (no-wrap + wall bounce) ----
function nextHead(pos, d) {
  const head = {x:pos.x, y:pos.y};
  if (d==='left') head.x--;
  else if (d==='right') head.x++;
  else if (d==='up') head.y--;
  else if (d==='down') head.y++;
  return head;
}

function tryMoveSnake(snake, d, bounceOnWall=true, isPlayer=false) {
  const next = nextHead(snake.body[0], d);
  if (!inBounds(next.x, next.y)) {
    if (bounceOnWall) {
      // bounce: reverse direction, no movement this tick
      const opposite = { up:'down', down:'up', left:'right', right:'left' };
      snake.nextDir = opposite[d];
      snake.dir = snake.nextDir;
      if (isPlayer) sfxBounce();
      return false;
    } else {
      return false;
    }
  }
  const oldTail = snake.body[snake.body.length-1];
  snake.body.unshift(next);
  snake.lastTail = {...oldTail};
  snake.body.pop();
  return true;
}

function undoMove(snake) { snake.body.shift(); if (snake.lastTail) snake.body.push(snake.lastTail); }
function growSnake(snake, n=1) { for (let i=0;i<n;i++){ const tail=snake.body[snake.body.length-1]; snake.body.push({...tail}); }}

function step() {
  dir = nextDir;
  tryMoveSnake(player, dir, true, true);
  centerCamera();

  // Apples
  const aIndex = apples.findIndex(p => cellEq(p, player.body[0]));
  if (aIndex !== -1) {
    apples.splice(aIndex,1); sfxApple();
    score += 1; if (score>best){ best=score; localStorage.setItem('best-score-v9', best); }
    growSnake(player, 1); spawnApple();
  }

  // AI move (slower)
  if (tickCount % AI_STEP_INTERVAL === 0) {
    for (const s of npcs) {
      const opposite = { up:'down', down:'up', left:'right', right:'left' };
      if (Math.random() < 0.25) {
        const options = ['up','down','left','right'].filter(x=>x!==opposite[s.dir]);
        s.nextDir = options[rnd(options.length)];
      }
      s.dir = s.nextDir;
      const moved = tryMoveSnake(s, s.dir, true, false);
      // Bounce off player body (no clipping)
      const newHead = s.body[0];
      if (player.body.some(p=>cellEq(p, newHead))) {
        sfxBounce();
        undoMove(s);
        s.dir = opposite[s.dir]; s.nextDir = s.dir;
      }
    }
  }

  // Player with self
  for (let i=1;i<player.body.length;i++) if (cellEq(player.body[0], player.body[i])) return gameOver();

  // Player vs NPCs
  for (let i=0;i<npcs.length;i++) {
    const npc = npcs[i];
    const idx = npc.body.findIndex(p => cellEq(p, player.body[0]));
    if (idx !== -1) {
      const playerLen = player.body.length, targetLen = npc.body.length;
      if (playerLen >= targetLen) {
        sfxEatSnake();
        score += targetLen; if (score>best){ best=score; localStorage.setItem('best-score-v9', best); }
        growSnake(player, Math.min(targetLen, 40));
        replaceNPC(npc);
        return;
      } else {
        sfxBounce(); undoMove(player);
        const opposite = { up:'down', down:'up', left:'right', right:'left' };
        dir = opposite[dir]; nextDir = dir;
        return;
      }
    }
  }
}

function replaceNPC(old){ const idx=npcs.indexOf(old); if(idx!==-1) npcs.splice(idx,1); spawnNPC(); }
function spawnNPC(){ if (npcs.length>=NPC_MAX) return; const len = 3 + rnd(6); const s = newSnake(len, AI_STYLE, [player, ...npcs]); s.ai=true; npcs.push(s); }
function spawnApple(){ for(let i=0;i<2000;i++){ const pos={x:rnd(WORLD_COLS), y:rnd(WORLD_ROWS)}; const occupied=anyAt(pos, player.body) || npcs.some(s=>anyAt(pos, s.body)) || anyAt(pos, apples||[]); if(!occupied){ apples.push(pos); return; } }}

// ---- Rendering (camera) ----
function render() {
  // clear viewport
  ctx.fillStyle = '#061013'; ctx.fillRect(0,0,VIEW_SIZE,VIEW_SIZE);

  // grid within camera
  ctx.save();
  ctx.globalAlpha = 0.10; ctx.strokeStyle = '#0f1b1f'; ctx.lineWidth = 1;
  const startCol = Math.floor(camX / CELL);
  const endCol = Math.ceil((camX + VIEW_SIZE) / CELL);
  const startRow = Math.floor(camY / CELL);
  const endRow = Math.ceil((camY + VIEW_SIZE) / CELL);
  for (let x=startCol+1; x<endCol; x++) {
    const sx = Math.floor(x*CELL - camX);
    ctx.beginPath(); ctx.moveTo(sx,0); ctx.lineTo(sx,VIEW_SIZE); ctx.stroke();
  }
  for (let y=startRow+1; y<endRow; y++) {
    const sy = Math.floor(y*CELL - camY);
    ctx.beginPath(); ctx.moveTo(0,sy); ctx.lineTo(VIEW_SIZE,sy); ctx.stroke();
  }
  ctx.restore();

  // apples
  for (const p of apples) drawAppleWorld(p.x, p.y);

  // snakes
  for (const s of npcs) drawSnakeNeonWorld(s);
  drawSnakeNeonWorld(player, true);

  // HUD
  drawHUD();

  if (paused) overlay('Paused');
  if (dead) overlay('Game Over');
}

function worldToScreen(x, y){
  return { x: x*CELL - camX + CELL/2, y: y*CELL - camY + CELL/2 };
}

function drawSnakeNeonWorld(s, isPlayer=false) {
  if (s.body.length < 2) return;
  let pts = s.body.map(seg => worldToScreen(seg.x, seg.y));
  // glow
  ctx.save(); ctx.lineJoin='round'; ctx.lineCap='round'; ctx.shadowBlur=Math.max(8, CELL*0.8); ctx.shadowColor=s.style.neon; ctx.strokeStyle=s.style.neon; ctx.lineWidth=Math.max(6, CELL*0.78); drawSmoothPath(pts); ctx.restore();
  // edge
  ctx.lineJoin='round'; ctx.lineCap='round'; ctx.lineWidth=Math.max(6, CELL*0.72); ctx.strokeStyle=s.style.edge; drawSmoothPath(pts);
  // base
  ctx.lineWidth=Math.max(4, CELL*0.62); ctx.strokeStyle=s.style.base; drawSmoothPath(pts);
  // stripes
  ctx.lineWidth=Math.max(2, CELL*0.36);
  for (let i=0;i<pts.length-1;i++) { const p1=pts[i], p2=pts[i+1]; ctx.strokeStyle=(i%2===0)?s.style.stripe:'rgba(0,0,0,0.15)'; ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke(); }
  // gloss
  ctx.globalAlpha=0.35; ctx.lineWidth=Math.max(2, CELL*0.18); ctx.strokeStyle=s.style.highlight; drawSmoothPath(pts.map(p=>({x:p.x,y:p.y-1}))); ctx.globalAlpha=1;
  // eyes
  const head = pts[0]; const eye = Math.max(2, Math.floor(CELL*0.08));
  ctx.fillStyle='#000'; ctx.beginPath(); ctx.arc(head.x - CELL*0.18, head.y - CELL*0.18, eye, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(head.x + CELL*0.18, head.y - CELL*0.18, eye, 0, Math.PI*2); ctx.fill();
}

function drawSmoothPath(pts){ if (pts.length<2) return; ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y);
  for(let i=0;i<pts.length-1;i++){ const p0=pts[Math.max(0,i-1)], p1=pts[i], p2=pts[i+1], p3=pts[Math.min(pts.length-1,i+2)];
    const cp1x = p1.x + (p2.x - p0.x)/6, cp1y = p1.y + (p2.y - p0.y)/6;
    const cp2x = p2.x - (p3.x - p1.x)/6, cp2y = p2.y - (p3.y - p1.y)/6;
    ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
  } ctx.stroke();
}

function drawAppleWorld(cx, cy) {
  const p = worldToScreen(cx, cy);
  const r = Math.max(4, Math.floor(CELL*0.22));
  ctx.fillStyle='#e74c3c'; ctx.beginPath(); ctx.arc(p.x-2, p.y, r*0.95, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(p.x+2, p.y, r*0.95, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle='rgba(255,255,255,0.15)'; ctx.beginPath(); ctx.arc(p.x-4, p.y-3, r*0.45, 0, Math.PI*2); ctx.fill();
  ctx.strokeStyle='#5d3a1a'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(p.x, p.y-r*1.1); ctx.lineTo(p.x+2, p.y-r*1.45); ctx.stroke();
}

// On-canvas HUD
function drawHUD(){
  ctx.save();
  ctx.fillStyle='rgba(0,0,0,0.35)'; ctx.fillRect(8,8,180,46);
  ctx.fillStyle='#fff'; ctx.font='bold 14px -apple-system, system-ui, Segoe UI, Roboto';
  ctx.fillText('Score: ' + score, 16, 26);
  ctx.fillText('Best: ' + best, 16, 44);
  ctx.restore();
}

function overlay(text) {
  ctx.fillStyle = 'rgba(0,0,0,.55)'; ctx.fillRect(0,0,VIEW_SIZE, VIEW_SIZE);
  ctx.fillStyle = '#fff'; ctx.font = 'bold 28px -apple-system, system-ui, Segoe UI, Roboto'; ctx.textAlign = 'center';
  ctx.fillText(text, VIEW_SIZE/2, VIEW_SIZE/2);
  ctx.font = '14px -apple-system, system-ui, Segoe UI, Roboto';
  ctx.fillText('Tap to resume / restart', VIEW_SIZE/2, VIEW_SIZE/2 + 28);
}

function gameOver(){ dead=true; sfxDead(); }
</script>
</body>
</html>
